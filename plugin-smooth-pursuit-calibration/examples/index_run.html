<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <script src="https://unpkg.com/jspsych@8.0.0"></script>
  <script src="../src/index.js"></script>
  <script src="https://unpkg.com/@jspsych/plugin-html-button-response@2.0.0"></script>
  <link rel="stylesheet" href="https://unpkg.com/jspsych@8.0.0/css/jspsych.css">
</head>

<body></body>
<script>
  const jsPsych = initJsPsych({
    on_finish: function() {
      // Output the data to the screen
      //test();
    }
  });

  let timeline = [];

  var trial1 = {
    type: jsPsychHtmlButtonResponse,
    stimulus: '<p style="font-size:48px; line-height:1.5;">Hello! Press the button to initiate the smooth-pursuit trial demo. <br> On the next page, push the spacebar to begin, then follow the moving target with your gaze. <br> When the target pauses, push the space bar again. </p>',
    choices: ['Continue'],
    };
  timeline.push(trial1);

  const trial_rect = {
    type: jsPsychSmoothPursuitCalibration,
    stimulus: 'SP_target.png', // The path to the target image file
    animation_duration: 10000, // The duration of the animation in milliseconds
    stimulus_width: 40, // The width of the target image in pixels
    stimulus_height: 40, // The height of the target image in pixels
    path_height: window.innerHeight - 40, // The height of the path in pixels, with a 40px margin accounting for target size
    path_width: window.innerWidth - 40,  // The width of the path in pixels, with a 40px margin accounting for target size
    repetitions: 1, // The number of times the target will move along the path
    starting_location:[0,0] // The starting location of the target
  };
  timeline.push(trial_rect)

  const trial_line = {
    type: jsPsychSmoothPursuitCalibration,
    stimulus: 'SP_target.png', // The path to the target image file
    animation_duration: 10000, // The duration of the animation in milliseconds
    path_shape: "line", // The shape of the path
    path_height: 0, // The height of the path in pixels
    path_width: 1400, // The width of the path in pixels
    repetitions: 1, // The number of times the target will move along the path
    starting_location:[window.innerWidth/2, window.innerHeight/2],  // The starting location of the target
  };

  timeline.push(trial_line);
  jsPsych.run(timeline);

  function test() {
    const data = jsPsych.data.get().values(); // Convert jsPsych data to an array

    let test_results = "";

    // Filter out trials that are of type "smooth-pursuit-calibration"
    const calibrationTrials = data.filter(trial => trial.trial_type === "smooth-pursuit-calibration");

    // Loop through all calibration trials in the data
    calibrationTrials.forEach((trial, trialIndex) => {
      // Add trial data as a collapsible section with left-aligned, indented JSON
      const trialLabel = trial.trial_type ? `Trial Data (${trial.trial_type})` : "Trial Data";
      test_results += `<details><summary>${trialLabel} #${trialIndex + 1}</summary>
        <pre style="text-align:left; font-family:monospace; background:#f8f8f8; padding:8px; border-radius:4px;">${JSON.stringify(trial, null, 2)}</pre>
      </details>`;

      if (trial.path_width !== undefined && trial.path_height !== undefined && trial.target_presentation_time) {
        const pathWidth = trial.path_width;
        const pathHeight = trial.path_height;
        const targetLocations = trial.target_presentation_time;

        let outOfBounds = false;

        // Check each location in the target presentation time
        targetLocations.forEach((entry, index) => {
          const [x, y] = entry.loc; // Extract x and y coordinates

          // Validate x and y coordinates based on path dimensions with a 10px buffer
          if (
            x < -10 || x > pathWidth + 10 ||
            (pathHeight > 0 && (y < -10 || y > pathHeight + 10))
          ) {
            outOfBounds = true;
            console.log(`Trial ${trialIndex + 1}, Target ${index + 1}: Out of bounds at location (${x}, ${y}).`);
            test_results += `<p>❌ Trial ${trialIndex + 1}, Target ${index + 1}: Out of bounds at location (${x}, ${y}).</p>`;
          }
        });

        if (!outOfBounds) {
          test_results += `<p>✔️ Trial ${trialIndex + 1}: All target locations are within bounds.</p>`;
        }
      } else {
        // Provide feedback if required data is missing for bounds check
        if (trial.path_width === undefined) {
          test_results += `<p>❌ Trial ${trialIndex + 1}: Missing path_width.</p>`;
        }
        if (trial.path_height === undefined) {
          test_results += `<p>❌ Trial ${trialIndex + 1}: Missing path_height.</p>`;
        }
        if (!trial.target_presentation_time) {
          test_results += `<p>❌ Trial ${trialIndex + 1}: Missing target_presentation_time.</p>`;
        }
      }

      if (trial.start_time && trial.end_time && trial.animation_duration) {
        const actualDuration = trial.end_time - trial.start_time;

        console.log(`Trial ${trialIndex + 1}: Actual duration: ${actualDuration}, Expected duration: ${trial.animation_duration}`);

        // Compare the actual duration with the expected animation duration
        if (Math.abs(actualDuration - trial.animation_duration) < 3) { // Allow a small tolerance for floating-point differences
          test_results += `<p>✔️ Trial ${trialIndex + 1}: Actual duration matches expected duration (${trial.animation_duration} ms).</p>`;
        } else {
          test_results += `<p>❌ Trial ${trialIndex + 1}: Actual duration (${actualDuration} ms) does NOT match expected duration (${trial.animation_duration} ms).</p>`;
        }
      } else {
        // Provide feedback if required data is missing for duration check
        if (!trial.start_time) {
          test_results += `<p>❌ Trial ${trialIndex + 1}: Missing start_time.</p>`;
        }
        if (!trial.end_time) {
          test_results += `<p>❌ Trial ${trialIndex + 1}: Missing end_time.</p>`;
        }
        if (!trial.animation_duration) {
          test_results += `<p>❌ Trial ${trialIndex + 1}: Missing animation_duration.</p>`;
        }
      }
    });

    // Update the display with the test results
    jsPsych.getDisplayElement().innerHTML = test_results;
  }
</script>

</html>